import * as vscode from "vscode";
import * as fs from "fs";
import * as path from "path";
import { DEP_TO_TECH, INFRA_TOOLS } from "./techs";
import { getRepoUrl } from "./repo";

export function activate(context: vscode.ExtensionContext) {
	let disposable = vscode.commands.registerCommand("readme-generator.createReadme", async () => {
		const workspaceFolders = vscode.workspace.workspaceFolders;
		if (!workspaceFolders) {
			vscode.window.showErrorMessage("No workspace open");
			return;
		}


		const rootPath = workspaceFolders[0].uri.fsPath;

		const repo = await getRepo(rootPath)


		// 1. Escanear estructura del proyecto
		const structure = getFolderStructure(rootPath);

		// 2. Detectar tecnolog√≠as
		const techs = getProdDependencies(rootPath);

		const devDep = getDevDependencies(rootPath)

		// 3. Detectar scripts de package.json
		const scripts = getScripts(rootPath);

		const version = getPackageField(rootPath, "version")

		const license = getPackageField(rootPath, "license")

		const infraTools = getInfrastructureTools(rootPath)


		// 4. Armar contenido del README
		const readmeContent = `# ${path.basename(rootPath)}

		

		
## üè∑ Version: ${version}

## license: ${license}
		
## üìñ Description
This project was automatically generated by the **README Generator** extension.

## ‚öôÔ∏è Prod stack technologies
${techs.join(", ") || "Not found"}


## ‚öôÔ∏è Dev  stack technologies 
${devDep.join(", ") || "Not found"}

## üìú Scripts available
${scripts.length ? scripts.map(s => `- \`${s}\``).join("\n") : "No definidos"}


## üåê Deployment & Infrastructure
${infraTools.join(", ") || "Not found"} 


## Clone repository

## Clone repository
\`\`\`bash
git clone ${repo !== "No repository found" ? repo : ""}
\`\`\`


## üìÇ Project structure
\`\`\`
${structure}
\`\`\`
`;

		// 5. Guardar README.md
		const readmePath = path.join(rootPath, "README.md");
		fs.writeFileSync(readmePath, readmeContent);

		vscode.window.showInformationMessage("README.md generado con √©xito üöÄ");
	});

	context.subscriptions.push(disposable);
}

const ignoredFolders = ["node_modules", ".git", ".vscode", "dist", "build", ".idea"];

// Funci√≥n para generar estructura de carpetas m√°s clara
function getFolderStructure(dir: string, depth = 0): string {
	const files = fs.readdirSync(dir).filter(f => !ignoredFolders.includes(f));
	let result = "";

	for (const file of files) {
		const filePath = path.join(dir, file);
		const stats = fs.statSync(filePath);
		const indent = "  ".repeat(depth);

		if (stats.isDirectory()) {
			result += `${indent}üìÇ ${file}\n${getFolderStructure(filePath, depth + 1)}`;
		} else {
			result += `${indent}üìÑ ${file}\n`;
		}
	}

	return result;
}


function readPackageJson(rootPath: string): any | null {
	const pkgPath = path.join(rootPath, "package.json");
	if (!fs.existsSync(pkgPath)) return null;
	return JSON.parse(fs.readFileSync(pkgPath, "utf8"));
}



function getProdDependencies(rootPath: string): string[] {
	const pkg = readPackageJson(rootPath);
	if (!pkg) return [];

	const deps = { ...pkg.dependencies };
	return Object.keys(DEP_TO_TECH)
		.filter(dep => deps[dep])
		.map(dep => DEP_TO_TECH[dep]);
}



function getDevDependencies(rootPath: string): string[] {
	const pkg = readPackageJson(rootPath);
	if (!pkg) return [];

	const devDep = { ...pkg.devDependencies };
	const techs: string[] = Object.keys(devDep).filter(dep => devDep[dep]).map(dep => dep);



	return techs;
}


export function getInfrastructureTools(rootPath: string): string[] {
	const foundTools: string[] = [];

	for (const file in INFRA_TOOLS) {
		const filePath = path.join(rootPath, file);
		if (fs.existsSync(filePath)) {
			foundTools.push(INFRA_TOOLS[file]);
		}
	}

	return foundTools;
}
function getPackageField(rootPath: string, field: string): string {
	const pkgPath = path.join(rootPath, "package.json");

	if (fs.existsSync(pkgPath)) {
		const pkgJson = JSON.parse(fs.readFileSync(pkgPath, "utf8"));
		return pkgJson[field] || `unknown-${field}`;
	}

	return `unknown-${field}`;
}


// Funci√≥n para listar scripts de package.json
function getScripts(rootPath: string): string[] {
	const pkg = readPackageJson(rootPath);
	return pkg?.scripts ? Object.keys(pkg.scripts) : [];
}

async function getRepo(rootPath: string): Promise<string> {
	try {
		const remotes = await getRepoUrl(rootPath);
		return remotes;
	} catch (error) {
		console.error(error);
		return "No repository found";
	}
}

